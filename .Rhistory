map = BoolNetPerturb::cellFateMap(network, genes = c("TBET", "IFNG", "GATA3", "IL2", "IL4", "RORGT", "IL21", "FOXP3", "TGFB", "IL10"), label.rules = df.rules)
# Compute adjancency matrix & plot states
Adj = matrix(0, nrow = length(plot_labels), ncol = length(plot_labels))
colnames(Adj) = plot_labels
rownames(Adj) = plot_labels
for(cellType in plot_labels) {
finalStates = map$final[which(map$initial == cellType)]
for (state in finalStates) {
if (state %in% plot_labels) {
Adj[cellType, state] = Adj[cellType, state] + 1
}
}
}
# Plot using igraph
library(igraph)
net=graph.adjacency(Adj,mode="directed",weighted=TRUE,diag=FALSE) #the only difference between this and the weighted network code is that mode="directed"
for(cellType in plot_labels) {
if (Adj[cellType, cellType] > 0) {
print(cellType)
net[from = cellType, to = cellType ] = Adj[cellType, cellType]
}
}
layout.self = matrix(-2, ncol = 2, nrow = length(plot_labels))
rownames(layout.self) = plot_labels
colnames(layout.self) = c("x", "y")
layout.self['Th0', ] = c(0,0)
layout.self['Th1', ] = c(0.3,1)
layout.self['Th1R', ] =c(0.7,0.5)
layout.self['Th17', ] =c(1,0)
layout.self['iTreg', ]=c(0.7,-0.5)
layout.self['RORGT+', ]=c(0.3,-1)
layout.self["IL10+TGFB+", ] = c(-0.3,-1)
layout.self['IL10+',] = c(-0.7, -0.5)
layout.self['Th2R',] = c(-1, 0)
layout.self['Th2',] = c(-0.7, 0.5)
layout.self['TGFB+',] = c(-0.3, 1)
layout.self['TBET+',] = c(-1, -1)
layout.self['GATA3+',] = c(-1, -1.5)
print(layout.self)
regCellTypes = c("iTreg", "Th1R", "Th2R", "Tr1")
effCellTypes = c("Th1", "Th2", "Th17")
colors = c("orange", "skyblue", "green", "red", "grey")[1 + V(net)$name %in% c("Th0") + 2 * V(net)$name %in% regCellTypes + 3 * V(net)$name %in% effCellTypes  + 4 * V(net)$name %in% c("GATA3+", "TBET+")]
plt = plot.igraph(net, vertex.color = colors, vertex.size = 28, vertex.label=V(net)$name, layout=layout.self,  vertex.label.color="black",edge.color="black",edge.width=E(net)$weight/2, edge.arrow.size=1.5)
#plot.igraph(net, vertex.size = 20, vertex.label=V(net)$name, layout=layout.circle,vertex.label.color="black", edge.color="black")
return(Adj)
}
adj = createCellFateMap(network, micro_env = microenvironment, micro_val = pro_iTreg, insulin = 1,  df.rules = df.rules, plot_labels = c(labels, "IL10+TGFB+"))
#
# Why 12 states (13), but randomly only 10 (11) are used? TGFB+ & RORGT+ dropped? Why?
# Example iTreg. Why oversimplified .. compared to real network
#
# What is Tr1? It is not defined in the table
# Why Tr1 showing up in the heatmap (11), not so in the cell map fate (alos 11 states)
# Paper is highly inconsistent
#
#
# Clear Definitions of regulatory (iTreg, Th1R, Th2R, Tr1??) vs effector cells (Th1, Th2, Th17)? What about the rest??
#
#"IL10+TGFB+/iTreg", "Th1R/Th1R", "RORGT+/TGFB+"
createCellFateMap = function(network, micro_env, micro_val, insulin = 0, df.rules, plot_labels) {
micro_val[length(micro_val)] = insulin
print(micro_val)
print(network)
network = fixGenes(network, fixIndices = micro_env, values = micro_val)
print(network)
map = BoolNetPerturb::cellFateMap(network, genes = c("TBET", "IFNG", "GATA3", "IL2", "IL4", "RORGT", "IL21", "FOXP3", "TGFB", "IL10"), label.rules = df.rules)
# Compute adjancency matrix & plot states
Adj = matrix(0, nrow = length(plot_labels), ncol = length(plot_labels))
colnames(Adj) = plot_labels
rownames(Adj) = plot_labels
for(cellType in plot_labels) {
finalStates = map$final[which(map$initial == cellType)]
for (state in finalStates) {
if (state %in% plot_labels) {
Adj[cellType, state] = Adj[cellType, state] + 1
}
}
}
# Plot using igraph
library(igraph)
net=graph.adjacency(Adj,mode="directed",weighted=TRUE,diag=FALSE) #the only difference between this and the weighted network code is that mode="directed"
for(cellType in plot_labels) {
if (Adj[cellType, cellType] > 0) {
print(cellType)
net[from = cellType, to = cellType ] = Adj[cellType, cellType]
}
}
layout.self = matrix(-2, ncol = 2, nrow = length(plot_labels))
rownames(layout.self) = plot_labels
colnames(layout.self) = c("x", "y")
layout.self['Th0', ] = c(0,0)
layout.self['Th1', ] = c(0.3,1)
layout.self['Th1R', ] =c(0.7,0.5)
layout.self['Th17', ] =c(1,0)
layout.self['iTreg', ]=c(0.7,-0.5)
layout.self['RORGT+', ]=c(0.3,-1)
layout.self["IL10+TGFB+", ] = c(-0.3,-1)
layout.self['IL10+',] = c(-0.7, -0.5)
layout.self['Th2R',] = c(-1, 0)
layout.self['Th2',] = c(-0.7, 0.5)
layout.self['TGFB+',] = c(-0.3, 1)
layout.self['TBET+',] = c(-1, -1)
layout.self['GATA3+',] = c(-1, -1.5)
print(layout.self)
regCellTypes = c("iTreg", "Th1R", "Th2R", "Tr1", "IL10+", "TGFB+", "IL10+TGFB+")
effCellTypes = c("Th1", "Th2", "Th17")
colors = c("orange", "skyblue", "green", "red", "grey")[1 + V(net)$name %in% c("Th0") + 2 * V(net)$name %in% regCellTypes + 3 * V(net)$name %in% effCellTypes  + 4 * V(net)$name %in% c("GATA3+", "TBET+")]
plt = plot.igraph(net, vertex.color = colors, vertex.size = 28, vertex.label=V(net)$name, layout=layout.self,  vertex.label.color="black",edge.color="black",edge.width=E(net)$weight/2, edge.arrow.size=1.5)
#plot.igraph(net, vertex.size = 20, vertex.label=V(net)$name, layout=layout.circle,vertex.label.color="black", edge.color="black")
return(Adj)
}
adj = createCellFateMap(network, micro_env = microenvironment, micro_val = pro_iTreg, insulin = 1,  df.rules = df.rules, plot_labels = c(labels, "IL10+TGFB+"))
createCellFateMap = function(network, micro_env, micro_val, insulin = 0, df.rules, plot_labels) {
micro_val[length(micro_val)] = insulin
print(micro_val)
print(network)
network = fixGenes(network, fixIndices = micro_env, values = micro_val)
print(network)
map = BoolNetPerturb::cellFateMap(network, genes = c("TBET", "IFNG", "GATA3", "IL2", "IL4", "RORGT", "IL21", "FOXP3", "TGFB", "IL10"), label.rules = df.rules)
# Compute adjancency matrix & plot states
Adj = matrix(0, nrow = length(plot_labels), ncol = length(plot_labels))
colnames(Adj) = plot_labels
rownames(Adj) = plot_labels
for(cellType in plot_labels) {
finalStates = map$final[which(map$initial == cellType)]
for (state in finalStates) {
if (state %in% plot_labels) {
Adj[cellType, state] = Adj[cellType, state] + 1
}
}
}
# Plot using igraph
library(igraph)
net=graph.adjacency(Adj,mode="directed",weighted=TRUE,diag=FALSE) #the only difference between this and the weighted network code is that mode="directed"
for(cellType in plot_labels) {
if (Adj[cellType, cellType] > 0) {
print(cellType)
net[from = cellType, to = cellType ] = Adj[cellType, cellType]
}
}
layout.self = matrix(-2, ncol = 2, nrow = length(plot_labels))
rownames(layout.self) = plot_labels
colnames(layout.self) = c("x", "y")
layout.self['Th0', ] = c(0,0)
layout.self['Th1', ] = c(0.3,1)
layout.self['Th1R', ] =c(0.7,0.5)
layout.self['Th17', ] =c(1,0)
layout.self['iTreg', ]=c(0.7,-0.5)
layout.self['RORGT+', ]=c(0.3,-1)
layout.self["IL10+TGFB+", ] = c(-0.3,-1)
layout.self['IL10+',] = c(-0.7, -0.5)
layout.self['Th2R',] = c(-1, 0)
layout.self['Th2',] = c(-0.7, 0.5)
layout.self['TGFB+',] = c(-0.3, 1)
layout.self['TBET+',] = c(-1, -1)
layout.self['GATA3+',] = c(-1, -1.5)
print(layout.self)
regCellTypes = c("iTreg", "Th1R", "Th2R", "Tr1", "IL10+", "TGFB+", "IL10+TGFB+")
#effCellTypes = c("Th1", "Th2", "Th17")
colors = c("orange", "skyblue", "green", "red", "grey")[1 + V(net)$name %in% c("Th0") + 2 * V(net)$name %in% regCellTypes + 3 * V(net)$name %in% effCellTypes  + 4 * V(net)$name %in% c("GATA3+", "TBET+")]
plt = plot.igraph(net, vertex.color = colors, vertex.size = 28, vertex.label=V(net)$name, layout=layout.self,  vertex.label.color="black",edge.color="black",edge.width=E(net)$weight/2, edge.arrow.size=1.5)
#plot.igraph(net, vertex.size = 20, vertex.label=V(net)$name, layout=layout.circle,vertex.label.color="black", edge.color="black")
return(Adj)
}
adj = createCellFateMap(network, micro_env = microenvironment, micro_val = pro_iTreg, insulin = 1,  df.rules = df.rules, plot_labels = c(labels, "IL10+TGFB+"))
createCellFateMap = function(network, micro_env, micro_val, insulin = 0, df.rules, plot_labels) {
micro_val[length(micro_val)] = insulin
print(micro_val)
print(network)
network = fixGenes(network, fixIndices = micro_env, values = micro_val)
print(network)
map = BoolNetPerturb::cellFateMap(network, genes = c("TBET", "IFNG", "GATA3", "IL2", "IL4", "RORGT", "IL21", "FOXP3", "TGFB", "IL10"), label.rules = df.rules)
# Compute adjancency matrix & plot states
Adj = matrix(0, nrow = length(plot_labels), ncol = length(plot_labels))
colnames(Adj) = plot_labels
rownames(Adj) = plot_labels
for(cellType in plot_labels) {
finalStates = map$final[which(map$initial == cellType)]
for (state in finalStates) {
if (state %in% plot_labels) {
Adj[cellType, state] = Adj[cellType, state] + 1
}
}
}
# Plot using igraph
library(igraph)
net=graph.adjacency(Adj,mode="directed",weighted=TRUE,diag=FALSE) #the only difference between this and the weighted network code is that mode="directed"
for(cellType in plot_labels) {
if (Adj[cellType, cellType] > 0) {
print(cellType)
net[from = cellType, to = cellType ] = Adj[cellType, cellType]
}
}
layout.self = matrix(-2, ncol = 2, nrow = length(plot_labels))
rownames(layout.self) = plot_labels
colnames(layout.self) = c("x", "y")
layout.self['Th0', ] = c(0,0)
layout.self['Th1', ] = c(0.3,1)
layout.self['Th1R', ] =c(0.7,0.5)
layout.self['Th17', ] =c(1,0)
layout.self['iTreg', ]=c(0.7,-0.5)
layout.self['RORGT+', ]=c(0.3,-1)
layout.self["IL10+TGFB+", ] = c(-0.3,-1)
layout.self['IL10+',] = c(-0.7, -0.5)
layout.self['Th2R',] = c(-1, 0)
layout.self['Th2',] = c(-0.7, 0.5)
layout.self['TGFB+',] = c(-0.3, 1)
layout.self['TBET+',] = c(-1, -1)
layout.self['GATA3+',] = c(-1, -1.5)
print(layout.self)
regCellTypes = c("iTreg", "Th1R", "Th2R", "Tr1", "IL10+", "TGFB+", "IL10+TGFB+")
effCellTypes = vector() #c("Th1", "Th2", "Th17")
colors = c("orange", "skyblue", "green", "red", "grey")[1 + V(net)$name %in% c("Th0") + 2 * V(net)$name %in% regCellTypes + 3 * V(net)$name %in% effCellTypes  + 4 * V(net)$name %in% c("GATA3+", "TBET+")]
plt = plot.igraph(net, vertex.color = colors, vertex.size = 28, vertex.label=V(net)$name, layout=layout.self,  vertex.label.color="black",edge.color="black",edge.width=E(net)$weight/2, edge.arrow.size=1.5)
#plot.igraph(net, vertex.size = 20, vertex.label=V(net)$name, layout=layout.circle,vertex.label.color="black", edge.color="black")
return(Adj)
}
adj = createCellFateMap(network, micro_env = microenvironment, micro_val = pro_iTreg, insulin = 1,  df.rules = df.rules, plot_labels = c(labels, "IL10+TGFB+"))
seq(0)
seq(0, 10)
getCellDifferentiationVector(labels) {
basinSize = rep(0, length(labels))
names(basinSize) = labels
return(basinSize)
}
getCellDifferentiationVector(labels) {
basinSize = rep(0, length(labels))
names(basinSize) = labels
return(basinSize)
}
getCellDifferentiationVector = function(labels) {
basinSize = rep(0, length(labels))
names(basinSize) = labels
return(basinSize)
}
getCellDifferentiationVector(labels)
getCellDifferentiationBasinSizes = function(network, micro_env, micro_val, attractorLabels) {
basinSize = rep(0, length(attractorlabels))
names(basinSize) = attractorLabels
return(basinSize)
}
getCellDifferentiationVector(labels)
getCellDifferentiationBasinSizes(network, micro_env = microenvironment, micro_val = pro_Th0, labels)
getCellDifferentiationBasinSizes = function(network, micro_env, micro_val, attractorLabels) {
basinSize = rep(0, length(attractorLabels))
names(basinSize) = attractorLabels
return(basinSize)
}
getCellDifferentiationBasinSizes(network, micro_env = microenvironment, micro_val = pro_Th0, attractorLabels = labels)
?getAttractors
getCellDifferentiationBasinSizes(network, micro_env = microenvironment, micro_val = pro_Th0, insulin = 0, attractorLabels = labels)
getCellDifferentiationBasinSizes = function(network, micro_env, micro_val, insulin = 0, attractorLabels) {
basinSize = rep(0, length(attractorLabels))
names(basinSize) = attractorLabels
micro_val[length(micro_val)] = insulin
network = fixGenes(network, fixIndices = micro_env, values = micro_val)
attr = getAttractors(network)
return(attr)
}
getCellDifferentiationBasinSizes(network, micro_env = microenvironment, micro_val = pro_Th0, insulin = 0, attractorLabels = labels)
A = getCellDifferentiationBasinSizes(network, micro_env = microenvironment, micro_val = pro_Th0, insulin = 0, attractorLabels = labels)
A$attractors
A$attractors[1]
A$attractors[[1]]
A$attractors[1]
A$attractors[[1]
A$attractors[[1]]$involvedState
A$attractors[[1]]$involvedStates
A$attractors[[1]]$involvedStates
A$stateInfo
A$stateInfo[1]
A$stateInfo
A$attractors
A
A[1]
A
A$attractors
A$attractors[[1]]
A$stateInfo[[1]]
A$stateInfo[[1]][1]
A$stateInfo[[1]][2]
A$attractors[[1]]$involvedStates
A$attractors[[1]]$basinSize
A$stateInfo$attractorAssignment
A$stateInfo$table
head(A$stateInfo$table)
A$stateInfo$attractorAssignment
A$attractors[[1]]$basinSize
A = getCellDifferentiationBasinSizes(network, micro_env = microenvironment, micro_val = pro_Th0, insulin = 0, attractorLabels = labels)
A
BoolNetPerturb::labelAttractors(A, df.rules)
A$attractors[[1]]$basinSize
A$attractors
A$stateInfo$table
A$stateInfo$attractorAssignment
A$attractors
length(A$attractors)
getCellDifferentiationBasinSizes = function(network, micro_env, micro_val, insulin = 0, attractorLabels) {
basinSizes = rep(0, length(attractorLabels))
names(basinSizes) = attractorLabels
micro_val[length(micro_val)] = insulin
network = fixGenes(network, fixIndices = micro_env, values = micro_val)
attr = getAttractors(network)
attrLabels = BoolNetPerturb::labelAttractors(attr)
for (i in 1:length(attr$attractors)) {
basinSizes[attrLabels[i]] =  basinSize[attrLabels[i]] + attr$attractors[[i]]$basinSize
}
return(basinSizes)
}
A = getCellDifferentiationBasinSizes(network, micro_env = microenvironment, micro_val = pro_Th0, insulin = 0, attractorLabels = labels)
getCellDifferentiationBasinSizes = function(network, micro_env, micro_val, insulin = 0, attractorLabels, label.rules) {
basinSizes = rep(0, length(attractorLabels))
names(basinSizes) = attractorLabels
micro_val[length(micro_val)] = insulin
network = fixGenes(network, fixIndices = micro_env, values = micro_val)
attr = getAttractors(network)
attrLabels = BoolNetPerturb::labelAttractors(attr, label.rules = label.rules)
for (i in 1:length(attr$attractors)) {
basinSizes[attrLabels[i]] =  basinSize[attrLabels[i]] + attr$attractors[[i]]$basinSize
}
return(basinSizes)
}
A = getCellDifferentiationBasinSizes(network, micro_env = microenvironment, micro_val = pro_Th0, insulin = 0, attractorLabels = labels, label.rules = df.rules)
A
getCellDifferentiationBasinSizes = function(network, micro_env, micro_val, insulin = 0, attractorLabels, label.rules) {
basinSizes = rep(0, length(attractorLabels))
names(basinSizes) = attractorLabels
micro_val[length(micro_val)] = insulin
network = fixGenes(network, fixIndices = micro_env, values = micro_val)
attr = getAttractors(network)
print(attr)
attrLabels = BoolNetPerturb::labelAttractors(attr, label.rules = label.rules)
for (i in 1:length(attr$attractors)) {
basinSizes[attrLabels[i]] =  basinSize[attrLabels[i]] + attr$attractors[[i]]$basinSize
}
return(basinSizes)
}
A = getCellDifferentiationBasinSizes(network, micro_env = microenvironment, micro_val = pro_Th0, insulin = 0, attractorLabels = labels, label.rules = df.rules)
getCellDifferentiationBasinSizes = function(network, micro_env, micro_val, insulin = 0, attractorLabels, label.rules) {
basinSizes = rep(0, length(attractorLabels))
names(basinSizes) = attractorLabels
micro_val[length(micro_val)] = insulin
network = fixGenes(network, fixIndices = micro_env, values = micro_val)
attr = getAttractors(network)
print(attr)
attrLabels = BoolNetPerturb::labelAttractors(attr, label.rules = label.rules)
for (i in 1:length(attr$attractors)) {
basinSizes[attrLabels[i]] = basinSizes[attrLabels[i]] + attr$attractors[[i]]$basinSize
}
return(basinSizes)
}
A = getCellDifferentiationBasinSizes(network, micro_env = microenvironment, micro_val = pro_Th0, insulin = 0, attractorLabels = labels, label.rules = df.rules)
A
getCellDifferentiationBasinSizes(network, micro_env = microenvironment, micro_val = pro_Th0, insulin = 0, attractorLabels = labels, label.rules = df.rules)
MicroEnv = matrix(c(pro_Th0,pro_Th1,pro_Th2,pro_Th17,pro_iTreg,pro_Tr1), nrow = length(microenvironment), byrow = TRUE)
MicroEnv
MicroEnv = matrix(c(pro_Th0,pro_Th1,pro_Th2,pro_Th17,pro_iTreg,pro_Tr1), nrow = length(microenvironment))
MicroEnv
MicroEnv = matrix(c(pro_Th0,pro_Th1,pro_Th2,pro_Th17,pro_iTreg,pro_Tr1), nrow = length(microenvironment), byrow = TRUE)
MicroEnv
MicroEnv = matrix(c(pro_Th0,pro_Th1,pro_Th2,pro_Th17,pro_iTreg,pro_Tr1), ncol = length(microenvironment), byrow = TRUE)
MicroEnv
MicroEnv = matrix(c(pro_Th0,pro_Th1,pro_Th2,pro_Th17,pro_iTreg,pro_Tr1), ncol = length(microenvironment), byrow = TRUE)
colnames(MicroEnv) = microenvironment
rownames(MicroEnv) = c("pro_Th0", "pro_Th1", "pro_Th2", "pro_Th17", "pro_iTreg", "pro_Tr1")
MicroEnv
for(i in nrow(MicroEnv)) {
print(MicroEnv[i,])
}
for(i in nrow(MicroEnv)) {
print(MicroEnv[i,])
}
for(i in 1:nrow(MicroEnv)) {
print(MicroEnv[i,])
}
M = vector()
for(i in 1:nrow(MicroEnv)) {
pro_mic = MicroEnv[i,]
M = c(M, getCellDifferentiationBasinSizes(network, micro_env = microenvironment, micro_val = pro_mic, insulin = 0, attractorLabels = labels, label.rules = df.rules))
}
M = matrix(M, nrow = nrow(MicroEnv))
M = vector()
for(i in 1:nrow(MicroEnv)) {
pro_mic = MicroEnv[i,]
M = c(M, getCellDifferentiationBasinSizes(network, micro_env = microenvironment, micro_val = pro_mic, insulin = 0, attractorLabels = labels, label.rules = df.rules))
}
M = matrix(M, nrow = nrow(MicroEnv))
getCellDifferentiationBasinSizes = function(network, micro_env, micro_val, insulin = 0, attractorLabels, label.rules) {
basinSizes = rep(0, length(attractorLabels))
names(basinSizes) = attractorLabels
micro_val[length(micro_val)] = insulin
network = fixGenes(network, fixIndices = micro_env, values = micro_val)
attr = getAttractors(network)
attrLabels = BoolNetPerturb::labelAttractors(attr, label.rules = label.rules)
for (i in 1:length(attr$attractors)) {
basinSizes[attrLabels[i]] = basinSizes[attrLabels[i]] + attr$attractors[[i]]$basinSize
}
return(basinSizes)
}
M = vector()
for(i in 1:nrow(MicroEnv)) {
pro_mic = MicroEnv[i,]
M = c(M, getCellDifferentiationBasinSizes(network, micro_env = microenvironment, micro_val = pro_mic, insulin = 0, attractorLabels = labels, label.rules = df.rules))
}
M = matrix(M, nrow = nrow(MicroEnv))
M = vector()
for(i in 1:nrow(MicroEnv)) {
pro_mic = MicroEnv[i,]
print(getCellDifferentiationBasinSizes(network, micro_env = microenvironment, micro_val = pro_mic, insulin = 0, attractorLabels = labels, label.rules = df.rules))
}
getCellDifferentiationBasinSizes = function(network, micro_env, micro_val, insulin = 0, attractorLabels, label.rules) {
basinSizes = rep(0, length(attractorLabels))
names(basinSizes) = attractorLabels
micro_val[length(micro_val)] = insulin
network = fixGenes(network, fixIndices = micro_env, values = micro_val)
attr = getAttractors(network)
attrLabels = BoolNetPerturb::labelAttractors(attr, label.rules = label.rules)
for (i in 1:length(attr$attractors)) {
if (attrLabels[i] %in% attractorLabels) {
basinSizes[attrLabels[i]] = basinSizes[attrLabels[i]] + attr$attractors[[i]]$basinSize
}
}
return(basinSizes)
}
for(i in 1:nrow(MicroEnv)) {
pro_mic = MicroEnv[i,]
print(getCellDifferentiationBasinSizes(network, micro_env = microenvironment, micro_val = pro_mic, insulin = 0, attractorLabels = labels, label.rules = df.rules))
}
M = vector()
for(i in 1:nrow(MicroEnv)) {
pro_mic = MicroEnv[i,]
M = c(M, getCellDifferentiationBasinSizes(network, micro_env = microenvironment, micro_val = pro_mic, insulin = 0, attractorLabels = labels, label.rules = df.rules))
}
M = matrix(M, nrow = nrow(MicroEnv))
M
colnames(M) = labels
rownames(M) = rownames(MicroEnv)
M
heatmap(M)
heatmap.2(M)
p = ggplot(M)#, aes(variable, Name)) + geom_tile(aes(fill = rescale),
library(ggplots)
p = ggplot(M)#, aes(variable, Name)) + geom_tile(aes(fill = rescale),
library(ggplot2)
p = ggplot(M)#, aes(variable, Name)) + geom_tile(aes(fill = rescale),
library(ggplot2)
install.packages("ggplot2")
p = ggplot(M)#, aes(variable, Name)) + geom_tile(aes(fill = rescale),
library(ggplot2)
p = ggplot(M)#, aes(variable, Name)) + geom_tile(aes(fill = rescale),
M
M
plot(M)
heatmap(M)
library(reshape2)
library(ggplot2)
ggplot(melt(M), aes(Var1,Var2, fill=value)) + geom_raster()#, aes(variable, Name)) + geom_tile(aes(fill = rescale),
ggplot(melt(M), aes(microenvironment,Var2, fill=value)) + geom_raster()#, aes(variable, Name)) + geom_tile(aes(fill = rescale),
ggplot(melt(M), aes(microenv,Var2, fill=value)) + geom_raster()#, aes(variable, Name)) + geom_tile(aes(fill = rescale),
ggplot(melt(M), aes(Var1, Var2, fill=value)) + geom_raster()#, aes(variable, Name)) + geom_tile(aes(fill = rescale),
ggplot(melt(M), aes(Var1, Var2, fill=value)) + geom_raster()#, aes(variable, Name)) + geom_tile(aes(fill = rescale),
ggplot(melt(M), aes(Var1, Var2, fill=value)) + geom_tile(aes(fill = rescale),
+     colour = "white") + scale_fill_gradient(low = "white",
+     high = "steelblue")
ggplot(melt(M), aes(Var1, Var2, fill=value)) + geom_tile(aes(fill = rescale),
+     colour = "white") + scale_fill_gradient(low = "white",
+     high = "steelblue")
ggplot(melt(M), aes(Var1, Var2, fill=value)) + geom_tile(aes(fill = rescale),
+     colour = "white") + scale_fill_gradient(low = "white",
+     high = "steelblue"))
ggplot(melt(M), aes(Var1, Var2, fill=value)) + geom_tile(aes(fill = rescale),
+     colour = "white") + scale_fill_gradient(low = "white",
+     high = "steelblue"))
ggplot(melt(M), aes(Var1, Var2, fill=value)) + geom_tile(aes(fill = rescale),
+     colour = "white") + scale_fill_gradient(low = "white",
+     high = "steelblue")
ggplot(melt(M), aes(Var1, Var2, fill=value)) + geom_tile(aes(fill = rescale), colour = "white") + scale_fill_gradient(low = "white", high = "steelblue")
ggplot(melt(M), aes(Var1, Var2, fill=value)) + geom_tile(aes(fill = value), colour = "white") + scale_fill_gradient(low = "white", high = "steelblue")
melt(M)
ggplot(melt(M), aes(Var2, Var1, fill=value)) + geom_tile(aes(fill = value), colour = "white") + scale_fill_gradient(low = "white", high = "steelblue")
M
getCellDifferentiationBasinSizes(network, micro_env = microenvironment, micro_val = pro_Tr1, insulin = 0, attractorLabels = labels, label.rules = df.rules)
getCellDifferentiationBasinSizes(network, micro_env = microenvironment, micro_val = pro_Tr0, insulin = 0, attractorLabels = labels, label.rules = df.rules)
getCellDifferentiationBasinSizes(network, micro_env = microenvironment, micro_val = pro_Th0, insulin = 0, attractorLabels = labels, label.rules = df.rules)
matrix(1:10, nrow = 2)
# Compute entire matrix
M = vector()
for(i in 1:nrow(MicroEnv)) {
pro_mic = MicroEnv[i,]
M = c(M, getCellDifferentiationBasinSizes(network, micro_env = microenvironment, micro_val = pro_mic, insulin = 0, attractorLabels = labels, label.rules = df.rules))
}
M = matrix(M, nrow = nrow(MicroEnv), byrow = TRUE)
colnames(M) = labels
rownames(M) = rownames(MicroEnv)
M
library(reshape2)
library(ggplot2)
ggplot(melt(M), aes(Var2, Var1, fill=value)) + geom_tile(aes(fill = value), colour = "white") + scale_fill_gradient(low = "white", high = "steelblue")
ggplot(melt(M), aes(rev(Var2), Var1, fill=value)) + geom_tile(aes(fill = value), colour = "white") + scale_fill_gradient(low = "white", high = "steelblue")
ggplot(melt(M), aes(Var2, Var1, fill=value)) + geom_tile(aes(fill = value), colour = "white") + scale_fill_gradient(low = "white", high = "steelblue")
ggplot(melt(M), aes(Var2, rev(Var1), fill=value)) + geom_tile(aes(fill = value), colour = "white") + scale_fill_gradient(low = "white", high = "steelblue")
ggplot(melt(M), aes(Var2, Var1, fill=value)) + geom_tile(aes(fill = value), colour = "white") + scale_fill_gradient(low = "white", high = "steelblue")
ggplot(melt(M), aes(Var2, Var1, fill=value))
+ geom_tile(aes(fill = value), colour = "white")
+ scale_fill_gradient(low = "white", high = "steelblue")
+ scale_y_reverse()
ggplot(melt(M), aes(Var2, Var1, fill=value))
+ geom_tile(aes(fill = value), colour = "white")
+ scale_fill_gradient(low = "white", high = "steelblue")
ggplot(melt(M), aes(Var2, Var1, fill=value)) + geom_tile(aes(fill = value), colour = "white") + scale_fill_gradient(low = "white", high = "steelblue") + scale_y_reverse()
ggplot(melt(M), aes(Var2, Var1, fill=value)) + geom_tile(aes(fill = value), colour = "white") + scale_fill_gradient(low = "white", high = "steelblue")
ggplot(melt(M), aes(Var2, Var1, fill=value)) + geom_tile(aes(fill = value), colour = "white") + scale_fill_gradient(low = "white", high = "steelblue")
